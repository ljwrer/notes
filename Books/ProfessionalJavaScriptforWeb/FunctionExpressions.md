#第七章 函数表达式
 - 函数表达式的特征
 - 使用函数实现递归
 - 使用闭包定义私有变量
<!-- -->
 - 函数声明：	
 	- 函数声明提升：在执行代码之前会先读取函数声明
 - 函数表达式
	- 匿名函数（lambda函数），在使用前必须先赋值
	- 在把函数当成值来使用的情况下，都可以使用匿名函数 

#7.1 递归
使用命名函数表达式代替arguments.callee

	var fac=(function f(){});

#7.2 闭包
闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

当某个函数被调用时:

- 创建一个执行环境（execution context）及相应的作用域链。
- 使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）
- 在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境

![](http://7xkcnd.com1.z0.glb.clouddn.com/activeObject.png)


###执行环境（execution context）：

 - 每个执行环境都有一个表示变量的对象——`变量对象`
 - 全局环境的变量对象始终存在，函数的局部环境的变量对象只在函数执行的过程中存在
 - 在创建函数时，会创建一个预先包含全局变量对象的`作用域链`（外部作用域），这个作用域链被保存在内部的`[[Scope]]`属性中（只有函数定义会这样）
 - 当调用函数时，会为函数创建一个`执行环境`（词法环境），然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链（函数表达式直接创建，[[Scope]]为创建时的外部作用域）
 - 此后，又有一个`活动对象`（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端（最前端，拥有arguments对象，参数，函数内部var定义的变量，函数内部的函数定义）

>[http://www.cnblogs.com/fool/archive/2010/10/19/1855266.html  ](http://www.cnblogs.com/fool/archive/2010/10/19/1855266.html  )  
>之后会发生由 ECMA 262 中所谓'活动对象'完成的'变量实例化'(Variable Instatiation)的过程。此时会将函数的形式参数创建为可变对象的命名属性，如果调用函数时传递的参数与形式参数一致，则将相应参数的值赋给这些命名属性（否则，会给命名属性赋 undefined 值）。对于定义的内部函数，会以其声明时所用名称为可变对象创建同名属性，而相应的内部函数则被创建为函数对象并指定给该属性。变量实例化的最后一步是将在函数内部声明的所有局部变量创建为可变对象的命名属性。注：在这个过程中，除了实际参数有值外和函数定义外，其它都被'预解析'为undefined值


<!-- -->
 - 作用域链本质上是一个指向变量对象（即执行环境）的指针列表，它只引用但不实际包含变量对象
 - 无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量
 - 一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。

在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中（但不在最前端）  
因此，在函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数的活动对象

 - 在匿名函数从外部函数中被返回后，它的作用域链被初始化为包含外部函数的活动对象和全局变量对象（自由变量）
 - 匿名函数就可以访问在外部中定义的所有变量
 - 外部函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象
 - 当外部函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中
 - 直到匿名函数被销毁后，外部函数的活动对象才会被销毁

![](http://7xkcnd.com1.z0.glb.clouddn.com/closure.png)

##7.2.1 闭包与变量
 - 闭包只能取得包含函数中任何变量的最后一个值(并非匿名函数创建时的现场值)。
 - 闭包所保存的是整个变量对象，而不是某个特殊的变量。
 - 可以通过创建另一个匿名函数并立即执行强制让闭包的行为符合预期（IIFE）

##7.2.2 关于this对象
 - this 对象是在运行时基于函数的执行环境绑定的
 - 在全局函数中， this 等于 window
 - 当函数被作为某个对象的方法调用时， this 等于那个对象。
 - 匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。
 - 通过 call()或 apply()改变函数执行环境的情况下， this 就会指向其他对象

如何访问闭包的this:

 - 每个函数在被调用时都会自动取得两个特殊变量： this 和 arguments。
 - 内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量
 - 不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了(var that=this)
 - this和arguments存在同样的问题。如果想访问作用域中的 arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。
 - 语法的细微变化，都有可能意外改变 this 的值

##7.2.3 内存泄漏

 - 如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。
 - 创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用时
 - 定义一个变量保存所需的element元素的属性副本，建立闭包以后将element元素的引用设为`null`,可以缓解这个问题

#7.3 模仿块级作用域
 - JavaScript 没有块级作用域的概念。在块语句中定义的变量，实际上是在包含函数中而非语句中创建的
 - 即使像下面这样错误地重新声明同一个变量，也不会改变它的值（因为声明提升？）
 - 匿名函数可以用来模仿块级作用域
<!-- -->
		(function(){
			//这里是块级作用域
		})();

- 以上代码定义并立即调用了一个匿名函数。
- 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。
- 紧随其后的另一对圆括号会立即调用这个函数。
- 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数
- 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。
<!-- -->

  - JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。
  - 函数表达式的后面可以跟圆括号。
  - 要将函数声明转换成函数表达式，只要像给它加上一对圆括号即可。

#7.4 私有变量
 -  JavaScript 中没有私有成员的概念；所有对象属性都是公有的(没有private,都是public)
 -  任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。(除了闭包)
 -  私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。（区分函数定义和函数执行）

##7.4.1特权方法
有权访问私有变量和私有函数的公有方法称为特权方法
###构造函数中定义特权方法
特权方法作为闭包有权访问在构造函数中定义的所有变量和函数	

	function MyObject() {
		//私有变量和私有函数
		var privateVariable = 10;
	
		function privateFunction() {
				return false;
			}
			//特权方法
		this.publicMethod = function() {
			privateVariable++;
			return privateFunction();
		};
	}
 - 私有变量在的每一个实例中都不相同，因为每次调用构造函数都会重新创建这个方法。
 - 在构造函数中定义特权方法的缺点就是你必须使用构造函数模式来达到这个目的，针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。

###静态私有变量

	(function() {
		//私有变量和私有函数
		var privateVariable = 10;
	
		function privateFunction() {
				return false;
			}
			//构造函数
		MyObject = function() {};
		//公有/特权方法
		MyObject.prototype.publicMethod = function() {
			privateVariable++;
			return privateFunction();
		};
	})();	
 - 在私有作用域中，首先定义了私有变量和私有函数
 - 定义构造函数时使用函数表达式，定义在全局上，能够在私有作用域之外被访问到。
 - 公有方法是在构造函数原型上定义

<!-- -->
 - 私有变量和函数是由实例共享的
 - 所有实例都使用同一个函数

##7.4.2 模块模式
模块模式通过为单例添加私有变量和特权方法能够使其得到增强

	var singleton = function() {
		//私有变量和私有函数
		var privateVariable = 10;
		function privateFunction() {
				return false;
			}
			//特权/公有方法和属性
		return {
			publicProperty: true,
			publicMethod: function() {
				privateVariable++;
				return privateFunction();
			}
		};
	}();

- 使用一个返回对象的匿名函数
- 这个匿名函数内部，首先定义了私有变量和函数。
- 然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。

<!-- -->
- 由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。
- 从本质上来讲，这个对象字面量定义的是单例的公共接口。
- 这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的(requireJS)
- 以这种模式创建的每个单例都是 Object 的实例,但一般都是全局变量

##7.4.3 增强的模块模式
即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况

	var singleton = function() {
		//私有变量和私有函数
		var privateVariable = 10;
		function privateFunction() {
				return false;
			}
			//创建对象
		var object = new CustomType();
		//添加特权/公有属性和方法
		object.publicProperty = true;
		object.publicMethod = function() {
			privateVariable++;
			return privateFunction();
		};
		//返回这个对象
		return object;
	}();

#小结
在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结了函数表达式的特点。

 - 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。
 - 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
 - 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化。

当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。

 - 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
 - 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
 - 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。

使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。

 - 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
 - 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。

闭包还可以用于在对象中创建私有变量，相关概念和要点如下。

 - 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。
 - 有权访问私有变量的公有方法叫做特权方法。
 - 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。

JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。

