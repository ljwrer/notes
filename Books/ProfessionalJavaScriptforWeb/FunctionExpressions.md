#第七章 函数表达式
 - 函数表达式的特征
 - 使用函数实现递归
 - 使用闭包定义私有变量
<!-- -->
 - 函数声明：	
 	- 函数声明提升：在执行代码之前会先读取函数声明
 - 函数表达式
	- 匿名函数（lambda函数），在使用前必须先赋值
	- 在把函数当成值来使用的情况下，都可以使用匿名函数 

#7.1 递归
使用命名函数表达式代替arguments.callee

	var fac=(function f(){});

#7.2 闭包
闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

当某个函数被调用时:

- 创建一个执行环境（execution context）及相应的作用域链。
- 使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）
- 在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境

![](http://7xkcnd.com1.z0.glb.clouddn.com/activeObject.png)


###执行环境（execution context）：

 - 每个执行环境都有一个表示变量的对象——`变量对象`
 - 全局环境的变量对象始终存在，函数的局部环境的变量对象只在函数执行的过程中存在
 - 在创建函数时，会创建一个预先包含全局变量对象的`作用域链`（外部作用域），这个作用域链被保存在内部的`[[Scope]]`属性中（只有函数定义会这样）
 - 当调用函数时，会为函数创建一个`执行环境`（词法环境），然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链（函数表达式直接创建，[[Scope]]为创建时的外部作用域）
 - 此后，又有一个`活动对象`（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端（最前端，拥有arguments对象，参数，函数内部var定义的变量，函数内部的函数定义）

>http://www.cnblogs.com/fool/archive/2010/10/19/1855266.html  
>之后会发生由 ECMA 262 中所谓'活动对象'完成的'变量实例化'(Variable Instatiation)的过程。此时会将函数的形式参数创建为可变对象的命名属性，如果调用函数时传递的参数与形式参数一致，则将相应参数的值赋给这些命名属性（否则，会给命名属性赋 undefined 值）。对于定义的内部函数，会以其声明时所用名称为可变对象创建同名属性，而相应的内部函数则被创建为函数对象并指定给该属性。变量实例化的最后一步是将在函数内部声明的所有局部变量创建为可变对象的命名属性。注：在这个过程中，除了实际参数有值外和函数定义外，其它都被'预解析'为undefined值


<!-- -->
 - 作用域链本质上是一个指向变量对象（即执行环境）的指针列表，它只引用但不实际包含变量对象
 - 无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量
 - 一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。

在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中（但不在最前端）  
因此，在函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数的活动对象

 - 在匿名函数从外部函数中被返回后，它的作用域链被初始化为包含外部函数的活动对象和全局变量对象（自由变量）
 - 匿名函数就可以访问在外部中定义的所有变量
 - 外部函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象
 - 当外部函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中
 - 直到匿名函数被销毁后，外部函数的活动对象才会被销毁

![](http://7xkcnd.com1.z0.glb.clouddn.com/closure.png)

##7.2.1 闭包与变量
闭包只能取得包含函数中任何变量的最后一个值(并非匿名函数创建时的现场值)。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量

