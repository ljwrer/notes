# 第一部分 作用域和闭包
## 第 1 章　作用域是什么
### 1.1 编译原理

 - 分词/词法分析
 - 解析/语法分析
 - 代码生成

### 1.2 理解作用域

 - 引擎:从头到尾负责整个JavaScript程序的编译及执行过程。
 - 编译器:负责语法分析及代码生成等脏活累活
 - 作用域:负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

####LHS RHS
LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。

 - LHS失败
	 - 严格模式：ReferenceError
	 - 非严格模式：创建全局变量
 - RHS失败
	 - TypeError
		 - 函数调用
		 - 属性读取

## 第 2 章　词法作用域
### 2.2　欺骗词法
#### 2.2.1　eval

 - 严格模式：新建作用域
 - 非严格模式：当前作用域

#### 2.2.1　with

 - with内作LHS引用
 - var 提升至外部作用域（undefined）
 - const,let 不提升也不写入
 - 读取到属性则赋值
 - 读取不到则根据LHS写入全局或var所在的外部作用域
 - with创建了新的词法作用域

#### 2.2.3 性能
JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
如果引擎在代码中发现了eval(..)或with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道eval(..)会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。
最悲观的情况是如果出现了eval(..)或with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化

## 第 3 章　函数作用域和块作用域
匿名函数表达式缺点

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。


	//IIEF	
	(function(){})()
	//另一种IIFE
	(function(){ .. }())
	//去掉全局变量的IIFE
	(function IIFE( global ) {})( window );
	//解决undefined标识符的默认值被错误覆盖导致的异常的IIFE
	(function IIFE( undefined ) {
		var a;
		if (a === undefined) {
		    console.log( "Undefined is safe here!" );
		}
	})();
	//倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去。（UMD模式）
	(function IIFE( def ) {
	    def( window );
	})(function def( global ) {
	    var a = 3;
	    console.log( a ); // 3
	    console.log( global.a ); // 2
	});
	


